<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>青女</title>
      <link href="/2022/12/12/%E5%BF%83%E9%AD%94/"/>
      <url>/2022/12/12/%E5%BF%83%E9%AD%94/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1a17fc8ad30300277202deb422d611dafa3d9f0de76375b3d26a05dcfe50cdb6">e73adf521709cce713d6869736f5954655bc166861f1e4a4891fada754bc4244ce0324e1c5b86efa53fba8b8b57fa416791a0dee25994402805c8177c04a3ecd19656619775a01f4918b11fb1d990a72782b437748b675211bf0627cb267c2daf5268da092dd9884b40d51ec4e599ff799b86364bb84472fdb1b1c7900c8a6c2d0479530ef84198d5a9dd11ce169878886294ba08ea0bd5b5c3ba72d829d37642ca2add2abfb69ff3a41e18d1691b36f982d8018275834d58a43cf99ba12722cb593c3797388a808c9048172562d0729b024cb1ec600a1fdfd2aa14debd233a9d7166f4da704119d497cfd174eea547dffb87f61cccd35252a3eb1b1967f74d7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 她 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心魔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022下半年尾声</title>
      <link href="/2022/12/04/%E9%87%8D%E6%96%B0%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/12/04/%E9%87%8D%E6%96%B0%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><font color="greendx">time: – 2022/12/4</font></p><p><font color="\#9932CC">重新记录blog</font></p><blockquote><p>到过年的任务：<br>1.<span class="github-emoji"><span>⭕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b55.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>数据结构c语言版</p><p>2.<span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>python基础与应用，数据结构python版本…</p><p>3.单词</p></blockquote><blockquote><p><font color=" #AAAAFF">12.1晚上结束了高等数学，还剩下另一门数据结构，加油，12.29考试</font></p><p><font color=" #AAAAFF">12.4凌晨阿根廷险胜澳大利亚，挺进世界杯八强</font></p><p><font color=" #AAAAFF">12.10凌晨三点阿根廷点球大战胜荷兰，挺进世界杯四强</font></p><p><font color=" #AAAAFF">12.14凌晨三点阿根廷3：0击败克罗地亚，挺进世界杯决赛</font></p><p><font color=" #AAAAFF">倒计时7个小时（2022/12/18 15:55</font></p><p>夺冠了夺冠了,决赛太刺激了</p><p><font color="red">2022FIFA卡塔尔世界杯冠军——阿根廷</font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2022/09/06/python/"/>
      <url>/2022/09/06/python/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>学好python的方法：1、勤加练习，需要多敲代码，记住并且知道怎么使用；2、看基础讲解的书籍；3、进阶中高级，需要一些中高级的教程，或者试着解决一些有难度的问题；4、保持连续性，学习编程比较忌讳学习的过程中经常断；5、练习搭建项目。</p></blockquote><p><a href="https://www.php.cn/python-tutorials-462725.html">如何学好python-Python教程-PHP中文网</a></p><p><a href="https://zhuanlan.zhihu.com/p/29631043">如何高效学Python？ - 知乎 (zhihu.com)</a></p><p>基础→web→应用，穿插刷题</p><blockquote><p><font color="#806D9E">勤学似春起之苗，不见其增，而日有所长。</font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2022/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>哈工大   刘宏伟；袁春风；王道；数电部分知识 </p><p>typora+xmind</p><blockquote><p>我感觉全篇最重要就是P3里10:46的机器层级图了，一层都在其下一层的提供的功能基础上进行抽象并添加其他功能。不同的层之间也有相似之处，比如在历史发展中ISA层的CISC与RISC的混合，OS层的宏内核Monolithic Kernel与微内核Microkernel的混合</p></blockquote><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><p>计算机硬件系统的逻辑实现</p><p>略</p><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>1.计算机系统</p><ul><li>硬件：计算机的实体，如：主机、外设等</li><li>软件：由具有各类特殊功能的信息（程序）组成<ul><li>系统软件（用来管理整个计算机系统  <ul><li>语言处理程序</li><li>操作系统</li><li>服务性程序</li><li>数据库管理系统</li><li>网络软件</li></ul></li><li>应用软件（按任务需要编制成各种的程序</li></ul></li></ul><p>2.系统复杂性管理的方法1：抽象(还有3Y）</p><p>3.计算机系统的层次结构</p><img src="https://s2.loli.net/2022/08/15/8HvGPsfIUBZFKXz.png" alt="image-20220815203336378" style="zoom: 33%;"><img src="https://s2.loli.net/2022/08/15/blQqa4uomi9Uzhx.png" alt="层次结构" style="zoom:33%;"><p>4.计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性</p><p>​（指令系统、数据类型、寻址技术、I/O机理）<font color="red">有无乘法指令</font></p><p>​计算机组成：实现计算机体系结构所体现的属性（具体指令的实现）<font color="red">如何实现乘法指令</font></p><p>5.系统复杂性管理的方法2：3Y</p><pre><code>   - 层次化：将被设计的系统划分为多个模块或子模块   - 模块化：有明确定义（well-defined)的功能和接口   - 规则性：模块更容易被重（chong）用</code></pre><h4 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h4><p>1.冯·诺依曼机的特点</p><ul><li><p>世界上第一台冯诺依曼结构机器，1949年的EDVAC</p></li><li><p>现代计算机之父：冯诺依曼</p></li><li><p>五大组成部分：运算器、存储器、控制器、输入设备、输出设备</p></li><li><p>指令和数据以同等的地位存于存储器，可按址访问</p></li><li><p>指令和数据用二进制表示</p></li><li><p>指令由操作码和地址码构成</p></li><li><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><font color="#7093DB">存储程序</font>（程序存放在存储系统中</p></li><li><p>以运算器为中心</p></li></ul><img src="https://s2.loli.net/2022/08/15/VMfUljh2dJBIg7X.png" alt="冯诺依曼机硬件框图" style="zoom: 50%;"><blockquote><p>运算器ALU：算术运算、逻辑运算</p><p>存储器：存放数据和程序</p><p>控制器CU：指挥、控制程序的运行</p><p>输入设备：将信息转换成机器能识别的形式</p><p>输出设备：将结果转换成人们熟悉的形式</p></blockquote><p>2.冯诺依曼机改进</p><p>以存储器为中序的计算机硬件框图</p><img src="https://s2.loli.net/2022/08/15/rBfVDY6UcQWEHRm.png" alt="以存储器为中序的计算机硬件框图" style="zoom: 50%;"><p>现代计算机层次结构框图</p><img src="https://s2.loli.net/2022/08/15/NVghseQLJuontTv.png" alt="现代计算机层次结构框图" style="zoom:33%;"><img src="https://s2.loli.net/2022/08/15/j8VxJPBEbXSq9hY.png" alt="现代计算机框图" style="zoom:33%;"><p>每部分以后细化</p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h4><h4 id="运算方法和运算电路"><a href="#运算方法和运算电路" class="headerlink" title="运算方法和运算电路"></a>运算方法和运算电路</h4><h4 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h4><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="哈工大存储器（上）"><a href="#哈工大存储器（上）" class="headerlink" title="哈工大存储器（上）"></a>哈工大存储器（上）</h4><h4 id="哈工大存储器（中）"><a href="#哈工大存储器（中）" class="headerlink" title="哈工大存储器（中）"></a>哈工大存储器（中）</h4><p>一.概述</p><p>二.半导体存储芯片简介</p><p>三.随机存取存储器RAM</p><p>四.只读存储器ROM</p><p>1.<span class="github-emoji"><span>💭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ad.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>发展历程：</p><blockquote><p>早期的只读存储器——在厂家就写好了内容</p><p>改进1——用户可以自己写——一次性</p><p>改进2——可以多次写——要能对信息进行擦除</p><p>改进3——电可擦除——特定设备</p><p>改进4——电可擦除——直接连到计算机</p></blockquote><p>Q：可编程的只读存储器，不一定可以改写</p><p>2.分类</p><ul><li>掩模ROM(MROM):由厂家直接把信息做在ROM芯片上，用户不能修改，数据只能读不能擦除</li></ul><p>​     行列选择线交叉处有MOS管为“1”，行列选择线交叉处没有MOS管为“0”（厂家直接确定</p><ul><li>PROM（一次性编程）</li></ul><img src="https://s2.loli.net/2022/08/16/AaD8Tlk3xXnZghN.png" alt="PROM" style="zoom: 50%;"><p>熔丝断   为“0”    ；   熔丝未断   为“1”    ；破坏性编程</p><ul><li><p>EPROM（多次性编程）</p><p>N型沟道浮动栅MOS电路</p><img src="https://s2.loli.net/2022/08/16/ZiPNLbzdfTVMOsl.png" alt="![](https://s2.loli.net/2022/08/16/ZiPNLbzdfTVMOsl.png)" style="zoom: 50%;"><blockquote><p>G 栅极    S  源   D漏</p><p>D加正电压，形成浮动栅，S和D不导通 ，为“0”</p><p>D不加正电压，不形成浮动栅，S与D导通，为“1”</p><p>重新写入，要驱散浮动栅，紫外线全部擦洗即可，但信息擦擦比较麻烦</p></blockquote><img src="https://s2.loli.net/2022/08/16/TENiHK17q68aX2G.png" alt="image-20220816101404202" style="zoom: 33%;"></li><li><p>EEPROM（多次编程）</p></li></ul><p>电可擦写的可编程的ROM，可以局部擦写，也可以全部擦写</p><ul><li>Flash Memory（闪速型存储器）</li></ul><p>闪存，U盘</p><blockquote><p>EPROM 价格便宜，集成度高</p><p>EEPROM 点可擦洗重写</p><p>Flash 比EEPROM还要快，具备了RAM功能</p></blockquote><p>五.CPU和存储器的连接</p><p>1.存储器容量的扩展</p><ul><li><p>位扩展（增加存储字长）</p><p>/*把多个芯片当一个使用</p><p>用 <font color="red">2片</font> 1K x 4位存储芯片组成1K x 8位的存储器（10根地址线，8根数据线）</p><p>片选一定连接在一起，使两个芯片可以同时工作</p><img src="https://s2.loli.net/2022/08/16/WCfRSoPLYy845Du.png" alt="位扩展" style="zoom: 50%;"></li><li><p>字扩展（增加存储字的数量）</p></li></ul><p>用 <font color="red">2片&nbsp;</font> 1K x 8位 存储芯片组成 2K x8位的存储器（11根地址线，8根数据线）</p><p>不能同时进行工作，如果A10等于0选择第一个芯片，如果A10等于1选择第二个芯片，A10就是这两个芯片的片选信号</p><img src="https://s2.loli.net/2022/08/16/GY3nBuPMcbihqTa.png" alt="字扩展" style="zoom: 50%;"><p><font color="bluee">00000000000-0 1111111111分给第一个存储芯片；10000000000-1 1111111111分给第二个存储芯片</font></p><p><font color="bluee">(0-1023)   (1024-2047)</font></p><ul><li>同时扩展</li></ul><img src="https://s2.loli.net/2022/08/16/Nl7Jji3gEv9cHuO.png" alt="同时扩展" style="zoom:33%;"><p>用  <font color="red">8片</font>  1k x 4位存储芯片组成4K x 8位的存储器</p><blockquote><p>00 0000000000-00 1111111111)第一组芯片（0-1023）</p><p>01 0000000000-01 1111111111第二组芯片（1024-2047）</p><p>10 0000000000-10 1111111111第三组芯片（2048-3071）</p><p>11 0000000000-11 1111111111第四组芯片（3072-4095）</p><p>由A10和A11这两位判断要访问的地址空间到底在哪一组芯片中，采用译码器进行译码</p><p>00选择第一组 ；01选择第二组；10选择第三组；11选择第四组     //2 4译码器   </p></blockquote><p>2.存储器与CPU的连接</p><ul><li>地址线的连接</li><li>数据线的连接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li></ul><p>保存系统程序的的存储空间用ROM；保存配置信息的存储空间用ROM；用户程序区/系统程序运行区用RAM芯片</p><p>综合考虑；芯片数量尽可能少；片选逻辑尽可能简单</p><ul><li>其他  时序、负载</li></ul><details><summary>例4.1：</summary><img src="https://s2.loli.net/2022/08/16/uwgmjWvEn3ZTaXe.png" alt="例题4.1" style="zoom:50%;"><p>(1).写出对应的二进制地址码：<br>A15~A0</p><blockquote><p>0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0</p><p>0 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1</p><p>2K  x   8位    选择1片 2k x 8位ROM</p></blockquote><blockquote><p> 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 </p><p> 0 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1</p><p>1K x8位     选择2片1K x 4位RAM</p></blockquote><p>(2).确定芯片的数量及类型</p><p>(3).分配地址线</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>138译码器是什么…2  4译码器     46译码器</p><p>(4).确定片选信号</p><p>头疼，，，先放一边</p><img src="https://s2.loli.net/2022/08/16/g1ZEa8mHvytG6Ip.png" alt="image-20220816120848642" style="zoom:33%;"></details><p>例4.2： </p><p>六.存储器的校验</p><p>Q.编码的检测能力和纠错能力和什么有关？</p><p>A:任意两组合法代码之间二进制位的最少差异数</p><p>1.编码的最小距离</p><p>任意两组合法代码之间二进制位数的最少差异</p><p>编码的纠错、检错能力与编码的最小距离有关</p><blockquote><p><font color="bluee">L-1=D+C(D&gt;=C)</font></p><p>L:编码最小距离；D：检测错误的位数；C：纠正错误的位数</p><font color="red"></font><p><font color="red">汉明码就是具有一位纠错能力的编码</font></p></blockquote><p>2.汉明码的组成</p><ul><li>汉明码采用奇偶校验</li><li>汉明码采用分组校验</li><li>汉明码的分组是一种非划分方式</li></ul><blockquote><p>划分的分组方式：00100011→ <font color="red">1</font>0010<font color="red">0</font>0011</p></blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p>分成3组，每组有1位校验位，共包含4位数据位</p><blockquote><p>第一组1 3 5 7；第二组2 3 6 7；第三组4 5 6 7</p><p>第一组：xxxx1；第二组 ：xxx1x ；第三组  xx1xx  ；第四组:x1xxx  ;第五组:1xxxx</p></blockquote><img src="https://s2.loli.net/2022/08/16/r7uGviMsnb8q4Ul.png" style="zoom:33%;"><p>七. 提高访问速度的措施</p><p>存储墙</p><ul><li><p>采用高速器件</p></li><li><p>采用层次结构Cache-主存</p></li><li><p>调整主存结构</p><ul><li><p>单体多字系统（增加存储器的带宽</p></li><li><p>多体并行系统</p><ul><li><p>高位交叉（顺序编址  |体号|体内地址|）：主要用于存储器容量的扩展</p></li><li><p>低位交叉（各个体轮流编址   |体内地址|体号|）</p><p>不改变存储周期的前提下，增加存储器的带宽</p><p>主要用于存储器带宽和访问速度的提高</p></li></ul></li></ul></li></ul><blockquote><p>设四体低位交叉存储器，存取周期为T，总线传输周期为┏，为实现流水线方式存取，应满足</p><p>T=4┏</p><p>连续读取4个字所需时间为T+（4-1） ┏</p></blockquote><ul><li><p>高性能存储芯片</p><ul><li>SDRAM（同步DRAM）</li></ul><p>在系统时钟控制下进行读出和写入，<font color="red">CPU无需等待</font></p><ul><li><p>RDRAM </p><p>由Rambus开发，主要解决存储器带宽问题</p></li><li><p>带Cache的DRAM</p></li></ul><p>在DRAM芯片内集成了一个由SRAM组成的Cache，有利于猝发式读取</p></li></ul><h4 id="哈工大存储器-下"><a href="#哈工大存储器-下" class="headerlink" title="哈工大存储器(下)"></a>哈工大存储器(下)</h4><h5 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h5><p>1.概述</p><p>Cache解决CPU”空等“问题</p><p>程序访问的局部性原理：时间的局部性 、空间的局部性（当前要使用的以及把相邻的要使用的指令和数据放入Cache</p><blockquote><p><font color="#7093DB">空间的局部性是指：当前正在使用的指令或数据其相邻的指令或数据在不久的将来很可能会被使用。 时间的局部性是指：当前正在使用的指令或数据在不久的将来会被再次使用。 利用这两种局部性的策略： Cache的替换策略中的LRU（最近最少使用）算法，替换掉近期用的最少的字块。</font></p></blockquote><p>2.Cache工作原理</p><img src="https://s2.loli.net/2022/08/17/xGygUMV2h6DdNZS.png" alt="主存和缓存" style="zoom: 25%;"><blockquote><p>标记：主存块和Cache块之间的对应关系</p><p>主存和Cache块内地址一样</p><p>主存和缓存按块存储，块的大小相同，块内地址完全相同</p></blockquote><p>3.命中和未命中</p><p>缓存C块，主存共M块  M&gt;&gt;C </p><p>主存中有部分块被缓存到了Cache，并不是所有</p><blockquote><p>命中：</p><p>主存块调入缓存</p><p>主存块与缓存块建立了对应关系</p><p>用标记记录与某缓存块建立了对应关系的主存块号</p></blockquote><blockquote><p>未命中：</p><p>主存块未调入缓存，此时CPU必须去主存中获取相应的数据或指令</p><p>主存块与缓存块未建立对应关系</p></blockquote><blockquote><p>Cache的命中率：</p><p>CPU欲访问的信息在Cache中的比率</p><p>命中率与Cache的容量与块长有关</p><p>一般Cache块每块可取4-8个字</p><p>块长取一个存储周期内从主存调出的信息长度</p></blockquote><p>CRAY_1     16体交叉   块长取16个存储字</p><p>IBM 370/168   4体交叉  块长取4个存储字（64位 x 4 =256位） </p><p>4.Cache-主存系统的效率</p><blockquote><p>效率e与命中率有关</p><p>e=（访问Cache的时间/平均访问时间）x100%</p><p>访问效率：（tc到1）</p></blockquote><p>5.Cache的基本结构</p><blockquote><p>将主存地址映射到缓存中定位称为地址映射，将主存地址变换成缓存地址称为地址变换，当新的主存块需要调入缓存中，而它的可用位置又被占用时，需根据替换算法解决调入问题。</p><p>变换机构：将主存的块号转换成Cache的块号，在Cache中找到相应的块号进行访问</p><p>地址映射给出了主存的块可以放到Cache的哪些块中，变换机构完成了主存当中的一个块在Cache中哪一个块的查找操作</p></blockquote><img src="https://s2.loli.net/2022/08/18/2tgMbPTF5Wam1wJ.png" alt="Cache的基本结构" style="zoom: 50%;"><p>6.Cache的读写操作</p><blockquote><p>读</p><p>读操作不对Cache中任何信息进行修改，主存和Cache中信息是一致的</p></blockquote><img src="https://s2.loli.net/2022/08/18/Z7h8mc3LxXdRjg9.png" alt="Cache读操作" style="zoom:33%;"><blockquote><p>写</p><p>写操作会造成主存和Cache的不一致</p></blockquote><ul><li>写直达法（Write-through）/写通过</li></ul><p>写操作时数据既写入Cache又写入主存</p><p>写操作时间就是访问主存的时间</p><ul><li>写回法（Write-back）</li></ul><p>写操作只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存</p><p>7.Cache的改进</p><ul><li><p>增加Cache的级数</p><p>片载（片内)Cache      片外Cache </p></li><li><p>统一缓存和分立缓存</p><p>指令Cache     数据Cache</p><p>与指令执行的控制方式有关    是否流水</p></li></ul><p>Pentium     8K指令Cache     8K数据Cache</p><p>PowerPC620     32K指令Cache    32K数据Cache</p><p>8.Cache—主存地址映射</p><ul><li>直接映射</li></ul><blockquote><p>主存当中任意一个给定的块只能映射到/装载到某一个指定的Cache块中</p><p>映射时，任何一个区的第0块只能放到Cache存储体的子块0中…….</p><p>速度低，发生冲突可能性大</p><p>每个缓存块i可以和若干个主存块对应</p><p>每个主存块j只能和一个缓存块对应</p></blockquote><img src="https://s2.loli.net/2022/08/18/7Rho1tEsdXwr5qc.png" alt="直接映射" style="zoom:50%;"><ul><li>全相联映射</li></ul><blockquote><p>主存中任何一个块可以被放到Cache的任何一个块中</p><p>利用率高；</p><p>电路比较复杂，速度慢/；参加比较的位数比较长</p><p>直接映射和全相联走了两个极端</p></blockquote><img src="https://s2.loli.net/2022/08/18/9Do1G4BXw8AYUgd.png" alt="全相联映射" style="zoom:50%;"><ul><li>组相联映射</li></ul><blockquote><p>靠近CPU的Cache要求高速度，可以采用直接相联或者路数比较少的组相联</p><p>中间层次可以用组相联</p><p>距离CPU最远的Cache层次，可以用全相联</p></blockquote><img src="https://s2.loli.net/2022/08/18/P6TkvCsEg3c2IGo.png" alt="组相联" style="zoom: 33%;"><blockquote><p>总结：<br>直接相联  某一主存块只能固定映射到某一缓存块      不灵活</p><p>全相联    某一个主存块能映射到任一缓存块    成本高</p><p>组相联    某一主存块只能映射到某一缓存组中的任一缓存块</p><p><font color="#7093DB">直接映射优点是结构简单、速度快，但缺点有 Cache 利用率低、冲突概率大，一般用于用于靠近 CPU 的层次。 全相联映射优点是 Cache 的利用率，命中率高但缺点有电路复杂，速度较慢，比较位数长，成本高，一般适合距离 CPU 最远的层次。 组相联映射优点速度较快，Cache 的利用率较高，而缺点速度不如直接映射快，利用率不如全相联映射高，用于中间的 Cache 层次 。</font></p></blockquote><p>9.替换算法</p><ul><li><p>先进先出(FIFC)算法</p><p>有问题</p></li><li><p>近期最少使用(LRU)算法</p></li></ul><h5 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h5><p>1.概述</p><p>保存数据、文档、程序、音响资料</p><p>不直接与CPU交换信息，先调入主存</p><blockquote><p>磁表面存储器的技术指标：</p><p>记录密度（道密度、位密度</p><p>存储容量</p><p>平均寻址时间：寻道时间+等待时间   辅存的速度：寻址时间和磁头读写时间</p><p>数据传输率</p><p>误码率</p></blockquote><p>2.磁记录原理</p><p>3.硬磁盘存储器类型</p><ul><li>固定磁头和移动磁头（常用）</li><li>可换盘和固定盘（常用）</li></ul><p>4.硬磁盘存储器结构</p><img src="https://s2.loli.net/2022/08/17/TOZuPrVp7IHce1R.png" alt="硬磁盘存储器结构" style="zoom: 50%;"><p>磁盘驱动器：主轴    定位驱动    数据控制</p><p>磁盘控制器：</p><ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令</li><li>实现了主机和驱动器之间的数据格式转换</li><li>控制磁盘驱动器读写</li></ul><p>磁盘存储器是主机与磁盘驱动器之间的接口（对主机通过总线，对硬盘（设备）直接</p><p>盘片：由硬质铝合金材料制成</p><p>4.软磁盘存储器 </p><p>已经退出计算机市场了</p><table><thead><tr><th align="center"></th><th align="center">硬盘</th><th align="center">软盘</th></tr></thead><tbody><tr><td align="center">速度</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">磁头</td><td align="center">固定、活动       浮动</td><td align="center">活动     接触盘片</td></tr><tr><td align="center">盘片</td><td align="center">固定盘、盘组    大部分不可换</td><td align="center">可换盘片</td></tr><tr><td align="center">价格</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">环境</td><td align="center">苛刻</td><td align="center">不苛刻</td></tr></tbody></table><p>5.软盘片</p><img src="https://s2.loli.net/2022/08/17/QCjakVAwBJ4vPmX.png" alt="软盘片" style="zoom: 33%;"><blockquote><p>由聚酯薄膜制成</p><p>软盘就是方型的塑料盒里有一张磁带一样的环型软磁条.最大容量只有1.44MB.由于他的容易小,于2003年已经退出历史的舞台</p></blockquote><p>6.光盘存储器</p><p>采用光存储技术</p><p>利用激光读出和写入</p><ul><li>第一代光存储技术    采用非磁性介质，写入是一次性的 ，不可擦写 </li><li>第二代光存储技术     采用磁性介质   可擦写的</li></ul><p>存储原理：</p><blockquote><p>只读型和只写一次型      热作用</p><p>可擦写光盘     热磁效应</p></blockquote><h4 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h4><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><h4 id="主存储器与CPU连接"><a href="#主存储器与CPU连接" class="headerlink" title="主存储器与CPU连接"></a>主存储器与CPU连接</h4><p>一.磁盘存储器 —key：磁盘存取时间的计算</p><p>二.固态硬盘(SSD)</p><h4 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h4><p>磁盘存储器</p><p>固态硬盘SSD</p><h4 id="高速缓冲存储器-1"><a href="#高速缓冲存储器-1" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><h3 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h3>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2022/07/12/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
      <url>/2022/07/12/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><span class="github-emoji"><span>🎃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f383.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :</p><p><span class="github-emoji"><span>🎅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f385.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="https://s2.loli.net/2022/07/15/m1MDTzEJGhWZpQr.png" alt="幂函数" style="zoom:33%;"><img src="https://s2.loli.net/2022/07/15/OUcKVDfaAvxNGY6.png" alt="幂函数2" style="zoom:25%;"><h3 id="第一章-函数-极限-连续"><a href="#第一章-函数-极限-连续" class="headerlink" title="第一章 函数 极限 连续"></a>第一章 函数 极限 连续</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>映射   函数</p><p>符号函数  取整函数  分段函数  </p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>复合函数    <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>反函数</p><p>初等函数（幂函数 ，指数函数，对数函数，三角函数，反三角函数）</p><p>函数的性质：单调性，奇偶性，周期性，有界性</p><blockquote><p><font color="red">常考题型：①.函数的性质      ②.复合函数</font></p></blockquote><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>1.数列极限的定义</p><img src="https://s2.loli.net/2022/07/13/f1UBXnoS4xN7AdK.jpg" alt="数列极限定义" style="zoom: 50%;"><h3 id="第二章-导数，微分，应用-zap"><a href="#第二章-导数，微分，应用-zap" class="headerlink" title="第二章 导数，微分，应用:zap:"></a>第二章 导数，微分，应用<span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.基本初等函数的导数公式</p><img src="https://s2.loli.net/2022/07/27/AtWseCSxcTBY9Mo.png" alt="基本初等函数的导数公式" style="zoom:50%;"><h3 id="第三章-不定积分"><a href="#第三章-不定积分" class="headerlink" title="第三章 不定积分"></a>第三章 不定积分</h3><h3 id="第四章-定积分"><a href="#第四章-定积分" class="headerlink" title="第四章 定积分"></a>第四章 定积分</h3><h3 id="第五章-常微分方程"><a href="#第五章-常微分方程" class="headerlink" title="第五章 常微分方程"></a>第五章 常微分方程</h3><h3 id="第六章-中值定理-zap"><a href="#第六章-中值定理-zap" class="headerlink" title="第六章 中值定理:zap:"></a>第六章 中值定理<span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h3 id="第七章-多元微分学"><a href="#第七章-多元微分学" class="headerlink" title="第七章 多元微分学"></a>第七章 多元微分学</h3><h3 id="第八章-二重积分"><a href="#第八章-二重积分" class="headerlink" title="第八章 二重积分"></a>第八章 二重积分</h3>]]></content>
      
      
      <categories>
          
          <category> 数二 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><span class="github-emoji"><span>💛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f49b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f499.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💜</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f49c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f49a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>☁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2601.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><p><font color="#158BB8">数据结构三要素：逻辑结构，数据运算，物理(存储)结构</font></p><h5 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h5><blockquote><p>数据</p><p>数据元素：数据的基本单位，一个数据元素由若干数据项组成</p><p>数据项：构成数据元素的不可分割的最小单位</p><p>数据对象:性质相同的数据元素的集合，是数据的一个子集</p><p>数据结构：数据元素相互之间的关系称为结构</p><p><font color="#806D9E">数据&gt;数据元素&gt;数据项</font></p><p><font color="#806D9E">例：学生表&gt;个人记录&gt;学号、姓名…</font></p></blockquote><blockquote><p>逻辑结构</p><ul><li>线性结构  非线性结构</li><li>集合 线性  树  图</li></ul><p>物理结构</p><ul><li>顺序 链式 索引  散列</li></ul></blockquote><p>程序 = 数据结构  + 算法</p><blockquote><p>抽象数据类型（Abstract Data Type）ADT:<br>抽象数据类型可用（D,S,P)三元组表示</p><p>D：数据对象；S是D上的关系集;P是对D的基本操作集。</p></blockquote><h5 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h5><p>算法特性：</p><blockquote><p>有穷性</p><p>确定性</p><p>可行性</p><p>输入：零个或多个输入</p><p>输出：一个或多个输出</p></blockquote><p>算法设计的要求：</p><blockquote><p>正确性、可读性、健壮性、高效性</p></blockquote><p>算法效率从以下两个方面来考虑：<br>1.时间效率：指的是算法所耗费的时间</p><p>2.空间效率：指的是算法执行过程中所耗费的存储空间。</p><p>时间复杂度T(n)= O(f(n))</p><img src="https://s2.loli.net/2022/07/21/J2nt4QGR9HpsKL1.png" alt="img"><blockquote><p><font color="#158BB8">&nbsp;找到一个基本操作(最深层循环）</font></p><p><font color="#158BB8">分析该基本操作的执行次数x与问题规模n的关系x=f(n)</font></p><p><font color="#158BB8">x的数量级O(x)就是算法时间复杂度T(n)</font></p></blockquote><p>抓大头</p><p>时间复杂度是由嵌套最深层次语句的频度决定的</p><blockquote><p>最坏时间复杂度 、平均时间复杂度、最好时间复杂度</p><p>加法规则(max)、乘法规则(*)</p></blockquote><p>空间复杂度S(n)=O(f(n))</p><h3 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章  线性表"></a>第二章  线性表</h3><h5 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h5><p>线性表是具有相同特性的数据元素的一个有限序列</p><blockquote><p>表长、空表，线性表Linear List</p></blockquote><p>同一线性表中的元素必定具有相同的特性，数据元素之间的关系是线性关系</p><p>基本操作：</p><blockquote><p> InitList(&amp;L):初始化线性表</p><p>DestoryList(&amp;L):销毁线性表</p><p>ListInsert(&amp;L,i,e):插入操作</p><p>ListDelete(&amp;L,i,&amp;e):删除操作</p><p>LocateElem(L,e):按值查找</p><p>GetElem(L,i):按位查找</p><p>Length(L):求表长</p><p>PrintList(L):输出操作</p><p>Empty(L):判空操作</p></blockquote><h5 id="线性表的顺序实现"><a href="#线性表的顺序实现" class="headerlink" title="线性表的顺序实现"></a>线性表的顺序实现</h5><details><summary>顺序表静态实现</summary><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表的静态实现</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10   <span class="comment">// 定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//用静态的“数组”存放元素</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">//顺序表当前长度</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>{</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">    {</span><br><span class="line">       L.data[i]=<span class="number">0</span>;  <span class="comment">//将所有数据元素设置为默认初始值</span></span><br><span class="line">    }</span><br><span class="line">    L.length=<span class="number">0</span>; <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(SqList &amp;L)</span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    {</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%4d"</span>,L.data[i]); </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i, <span class="type">int</span> e)</span>{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span> || L.length&gt;=MaxSize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--) <span class="comment">//将第i个元素及之后元素后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;  <span class="comment">//在位置i处放e</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i ,<span class="type">int</span> &amp;e)</span>{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i &gt;L.length) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    e = L.data[i<span class="number">-1</span>]; <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j =i;j&lt;L.length;j++)</span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];  </span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="comment">//获取表L中第i个位置的元素的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span>{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法,按位查找失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L,<span class="type">int</span> e)</span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==e){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"按值查找成功，值%d所在的位置为第%d位\n"</span>,e,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;}</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"按值查找失败\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//退出循环则说明查找失败 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    SqList L;  <span class="comment">//声明一个顺序表 </span></span><br><span class="line">    <span class="type">bool</span> ret; <span class="comment">//查看返回值</span></span><br><span class="line">    InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    PrintList(L); <span class="comment">//打印顺序表</span></span><br><span class="line">    <span class="comment">// 首先手动再顺序表中赋值</span></span><br><span class="line">    L.data[<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">    L.data[<span class="number">1</span>]=<span class="number">22</span>;</span><br><span class="line">    L.data[<span class="number">2</span>]=<span class="number">33</span>;</span><br><span class="line">    L.length=<span class="number">3</span>;<span class="comment">//总计3个元素</span></span><br><span class="line">    PrintList(L);</span><br><span class="line">    ret = ListInsert(L, <span class="number">4</span>, <span class="number">44</span>); <span class="comment">//往第四个位置插入44这个元素</span></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入成功\n"</span>);</span><br><span class="line">        PrintList(L);  <span class="comment">//打印插入成功后的顺序表</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>;  <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(ListDelete(L,<span class="number">4</span>,e))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"已删除第4个元素,删除元素值为:%d\n"</span>,e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法，删除失败\n"</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获取到表L中第1个位置的值为:%d\n"</span>,GetElem(L,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    LocateElem(L,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    PrintList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">  <span class="number">11</span>  <span class="number">22</span>  <span class="number">33</span></span><br><span class="line">--------------------</span><br><span class="line">插入成功</span><br><span class="line">  <span class="number">11</span>  <span class="number">22</span>  <span class="number">33</span>  <span class="number">44</span></span><br><span class="line">--------------------</span><br><span class="line">已删除第<span class="number">4</span>个元素,删除元素值为:<span class="number">44</span></span><br><span class="line">  <span class="number">11</span>  <span class="number">22</span>  <span class="number">33</span></span><br><span class="line">--------------------</span><br><span class="line">获取到表L中第<span class="number">1</span>个位置的值为:<span class="number">11</span></span><br><span class="line">按值查找成功，值<span class="number">22</span>所在的位置为第<span class="number">2</span>位</span><br><span class="line">  <span class="number">11</span>  <span class="number">22</span>  <span class="number">33</span></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></tbody></table></figure></details><details><summary>顺序表</summary><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span>    <span class="comment">//动态分配        </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组创建线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList</span><span class="params">(SqList *&amp;L, ElemType a[],<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        L-&gt;data[i]=a[i];</span><br><span class="line">    L-&gt;length=n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线性表InitList(L)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList *&amp;L)</span></span><br><span class="line">{</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="comment">//分配存放线性表的空间</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表DestroyList(L)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SqList *&amp;L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定是否为空表ListEmpty(L)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(SqList *L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span>(L-&gt;length==<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表的长度ListLength(L)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqList *L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span>(L-&gt;length);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出线性表DispList(L)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(SqList *L)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(ListEmpty(L)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,L-&gt;data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//求某个数据元素值GetElem(L,i，e)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetElem</span><span class="params">(SqList *L,<span class="type">int</span> i,ElemType &amp;e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入数据元素ListInsert(L,i,e)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *&amp;L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    i--;</span><br><span class="line">    e=L-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;length;j&gt;<span class="number">1</span>;j--)</span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">    L-&gt;data[i]=e;</span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据元素ListDelete(L,i,e)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList *&amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    i--;</span><br><span class="line">    e=L-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;L-&gt;length<span class="number">-1</span>;j++)</span><br><span class="line">        L-&gt;data[j]=L-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    SqList *sq;</span><br><span class="line">    ElemType x[<span class="number">6</span>]={<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>};</span><br><span class="line">    CreateList(sq, x, <span class="number">6</span>);</span><br><span class="line">    DispList(sq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抄都能抄好多错误，。。。</span></span><br></pre></td></tr></tbody></table></figure></details><h5 id="线性表的链式实现"><a href="#线性表的链式实现" class="headerlink" title="线性表的链式实现"></a>线性表的链式实现</h5><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h3 id="第三章-栈、队列、数组"><a href="#第三章-栈、队列、数组" class="headerlink" title="第三章 栈、队列、数组"></a>第三章 栈、队列、数组</h3><h3 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h3><h3 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h3><h5 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h5><blockquote><p>空树、根、子树</p><p>结点、根结点</p><p>结点的度:结点拥有的子树数</p><p>树的度:树内各结点的度的最大值</p><p>叶子结点/终端结点:度为0</p><p>结点的子树的根称为该节点的孩子，该结点称为孩子的双亲</p><p>兄弟结点，堂兄弟结点(双亲在同一层)</p><p>结点的祖先:从根到该结点的所经分支上的所有结点</p><p>结点的子孙</p><p>树的深度：树中结点最大层次</p><p>有序树：树中结点的各子树从左至右有次序       //无序树</p><p>森林</p><p><font color="#806D9E">树一定是森林，森林不一定是树</font></p></blockquote><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p><font color="#806D9E">左子树&nbsp; 右子树</font></p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><blockquote><p>1.每个结点最多有两个孩子(二叉树不存在度大于2的结点)</p><p>2.左右子树，次序不能颠倒，要加以区分</p></blockquote><p>二叉树的五种形态：<br>空二叉树，根和空左右子树，根和左子树，根和右子树，根和左右子树</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>利用二叉树求解表达式的值</p><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6><p>满二叉树 ：深度为k且结点数为2的k次方-1</p><p>完全二叉树：基于满二叉树，只能连续缺右下角的结点(最后几个结点)</p><blockquote><p>性质4、5关于完全二叉树</p><ol><li>cc</li><li>cc</li><li>对任何一棵二叉树T,如果其叶子数为n0，度为2的结点数为n2，则n0=n2+1</li><li>具有n个结点的完全二叉树的深度为log2n(向下取整)+1</li><li>双亲结点、孩子结点编号之间的关系，i结点，双亲i/2向下取整，左孩子2i，右孩子2i+1</li></ol></blockquote><h6 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h6><ul><li>顺序存储结构：按满二叉树存入数组中，（适合存满二叉树和完全二叉树，不浪费</li><li>链式存储结构<ul><li>二叉链表：lchild |data |rchild</li><li>三叉链表：lchild | data |parent |rchild</li></ul></li></ul><p>在n个结点的二叉链表中，有n+1个空指针域</p><h6 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h6><blockquote><ul><li>先序(根)遍历DLR:</li><li>中序(根)遍历LDR:</li><li>后序(根)遍历LRD:</li><li>层次遍历</li></ul></blockquote><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>用二叉树表示算术表达式</p><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>由遍历序列确定二叉树 p87</p><p>先+中   中+后</p><h6 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h6><p>算法  <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h6 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h6><p>利用二叉链表中的空指针域</p><p>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；</p><p>如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继；</p><p>这种改变指向的指针称为“线索”。</p><p>线索化</p><p>lchild  |  ltag  | data  | rtag  | rchild</p><p>ltag=0,lchild指向该节点的左孩子；ltag=1，lchild指向该结点的前驱</p><blockquote><p>先序线索二叉树</p><p>中序线索二叉树</p><p>后序线索二叉树</p></blockquote><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h5><h6 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h6><ol><li><p>双亲表示法：找双亲容易，找孩子难  、、、代码</p></li><li><p>孩子链表：把每个结点的孩子结点排列起来，看成是一个线性表；找孩子容易，找双亲难</p><p>带双亲的孩子链表：结合起来</p></li><li><p>孩子兄弟表示法</p><p>用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点</p><p>（左孩子右兄弟</p></li></ol><h6 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h6><p>用二叉链表做媒介</p><blockquote><p>将树转换成二叉树：</p><ol><li>加线：在兄弟之间加一连线</li><li>抹线：对每个结点，除了其左孩子外，去掉其与其余孩子之间的关系</li><li>旋转：以树的根结点为轴心，将整个树顺时针转45°</li></ol><p><font color="#F03752">树变二叉树：兄弟相连留长子</font></p></blockquote><blockquote><p>将二叉树转换成树：</p><ol><li>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子…沿分支找到的所有右孩子，都与p的双亲用线连起来</li><li>抹线：抹掉原二叉树中双亲与右孩子的连线</li><li>将结点按层次排序，形成树的结构</li></ol><p><font color="#F03752">二叉树变树：左孩右右连双亲，去掉原来右孩线</font></p></blockquote><h6 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h6><blockquote><p>森林转换成二叉树：</p><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p><p><font color="#F03752">森林变二叉树：树变二叉根相连</font></p></li></ol></blockquote><blockquote><p>二叉树转换成森林：</p><ol><li>抹线：将二叉树中根结点与其右孩子连线，及沿着右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</li><li>还原：将孤立的二叉树还原成树</li></ol><p><font color="#F03752">二叉树变森林：去掉全部右孩线，孤立二叉再还原</font></p></blockquote><h6 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h6><p>树的遍历：先根，后根，层次</p><p>森林的遍历：</p><blockquote><p>将森林看作由三部分构成；</p><ol><li>森林中第一棵树的根结点</li><li>森林中第一棵树的子树森林</li><li>森林中其它树构成的森林</li></ol></blockquote><blockquote><p>先序遍历：<br>若森林不空，则：</p><p>1.访问森林中第一棵树的根结点</p><p>2.先序遍历森林中第一棵树的子树森林</p><p>3.先序遍历森林中（除第一棵树）其余树构成的森林</p><p><font color="#F03752">依次从左至右对森林中每一棵树进行先根遍历</font></p></blockquote><blockquote><p>中序遍历：<br>若森林不空，则：</p><ol><li>中序遍历森林中第一棵树的子树森林</li><li>访问森林中每一棵树的根结点</li><li>中序遍历森林中（除了第一棵树）其余树构成的森林</li></ol><p><font color="#F03752">依次从左至右对森林中每一棵树进行后根遍历</font></p></blockquote><p>总结：</p><p>二叉树：先 中 后 层次</p><p>树：先 后 层次</p><p>森林：先 中(对应树的”后“)</p><h5 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h5><p>判断树：用于描述分类过程的二叉树</p><p>哈夫曼树（最优二叉树）</p><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><blockquote><p>路径</p><p>结点的路径长度：两结点间路径上的分支数</p><p>树的路径长度：从树根到每一个结点的路径长度之和。记作:TL</p><p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</p><p>权</p><p>结点的带权路径长度：从根结点到该节点之间的路径长度与该结点的权的乘积</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作WPL</p><p>哈夫曼树：WPL最短的二叉树，最优二叉树</p><p>哈夫曼算法</p></blockquote><h6 id="哈夫曼树构造算法"><a href="#哈夫曼树构造算法" class="headerlink" title="哈夫曼树构造算法"></a>哈夫曼树构造算法</h6><blockquote><ol><li>构造森林全是根</li><li>选用两小造新树</li><li>删除两小添新人</li><li>重复2、3剩单根</li></ol></blockquote><p><font color="#F03752">包含n个叶子结点的哈夫曼树中共有2n-1个结点（经过n-1次合并</font></p><blockquote><p>在哈夫曼算法中，初始有n棵二叉树，经过n-1次合并最终形成哈夫曼树，产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。</p><p>可见，哈夫曼树中共有n+n-1=2n-1个结点，且其所有分支结点的度均不为1</p></blockquote><h6 id="哈夫曼树构造算法的实现"><a href="#哈夫曼树构造算法的实现" class="headerlink" title="哈夫曼树构造算法的实现"></a>哈夫曼树构造算法的实现</h6><p>采用顺序存储结构——一维结构数组</p><p>p104</p><h3 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h3><h5 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h5><blockquote><p>G=(V,E)  V:顶点集   E:边集</p></blockquote><blockquote><p>无向图、有向图，完全图(n个顶点，n(n-1)/2条边[无向图]，n(n-1)条边[有向图])</p><p>稀疏图(e&lt;nlogn)、稠密图</p><p>简单图、多重图</p><p>顶点的度TD(v)、入度ID(v):以v为终点、出度OD(v)：以v为始点</p><p>路径、回路、简单路径、简单回路、路径长度、点到点的距离</p><p>连通、强连通、连通图、强连通图</p><p>子图连通分量、强连通分量</p><p>生成树、生成森林</p><p>边的权、带权图(也叫网)</p></blockquote><h5 id="图的存储结构-zap"><a href="#图的存储结构-zap" class="headerlink" title="图的存储结构:zap:"></a>图的存储结构<span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h5><ul><li>邻接矩阵:数组表示法</li><li>邻接表:链式存储结构</li><li>十字链表:存储有向图</li><li>邻接多重表:存储无向图</li></ul><h5 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h5><p>代码</p><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><blockquote><p>深度优先遍历DFS  ：一条道走到黑</p><p>广度优先遍历BFS   ：一层一层依次访问邻接点</p></blockquote><h5 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h5><ul><li>最小生成树<ul><li>Prim算法：选顶点</li><li>Kruskal算法：选边(依次选择权值最小的边)</li></ul></li><li>最短路径<ul><li>dijkstra算法：单源最短路径</li><li>Floyd算法 ：各顶点之间的最短路径</li></ul></li><li>拓扑排序<ul><li>AOV网</li></ul></li><li>关键路径<ul><li>AOE网</li></ul></li></ul><h3 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h3><h3 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h3>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Checklist</title>
      <link href="/2022/07/06/Checklist/"/>
      <url>/2022/07/06/Checklist/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>[toc]</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h5><p>一些基本概念 、时间复杂度 、 空间复杂度</p><h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h5><p>代码</p><p>顺序表静态分配 、动态分配</p><h4 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h4><p>2的次方值：</p><img src="https://s2.loli.net/2022/08/09/jrqQlHkGTxf9KcA.png" alt="2的次方值" style="zoom: 67%;"><p>原反补移码：</p><img src="https://s2.loli.net/2022/08/10/Mfto1J4FVD2jlPB.png" alt="原反补移" style="zoom:50%;"><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> checklist </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>[toc]</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1.internet：通用名词，互联网/互连网  </p><p>   Internet：专业名词，因特网</p><p>2.因特网发展三个阶段</p><img src="https://s2.loli.net/2022/07/14/jytEWJs8BAHPhFm.png" alt="因特网发展的三个阶段" style="zoom: 25%;"><p>3.因特网服务提供者ISP(Internet Service Provider)</p><p>电信，移动，联通</p><p>基于ISP的三层结构的因特网→基于ISP的多层次结构的因特网</p><p>4.因特网的标准化工作</p><p><font color="red">面向公众</font>   IETF发布的RFC文档</p><p>RFC(Request For Comments)技术文档</p><p>一些组织和正式标准的四个阶段：</p><p><img src="https://s2.loli.net/2022/07/14/cvCn21a93V6tUDq.png" alt="一些组织和正式标准的四个阶段"></p><p>5.因特网组成</p><p>边缘部分  核心部分</p><h4 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h4><p>电路交换(Circuit Switching):建立连接→数据传送→释放连接：比特流直达终点</p><p>报文交换(Message Switching)：存储转发方式</p><p>分组交换(Packeet Switching)：存储转发方式</p><p>发送方(构造分组，发送分组)   路由器(缓存分组，转发分组) 接收方(接收分组，还原报文)</p><p>分组交换：</p><ul><li>数据报服务</li><li>虚电路服务：呼叫建立→数据传输→虚电路释放</li></ul><blockquote><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>此处报文交换和分组交换会有计算题</p></blockquote><h4 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h4><blockquote><p>一些互相连接的，自治的计算机的集合。</p></blockquote><p>分类：</p><ul><li>按交换技术分：电路交换网络，报文交换网络，分组交换网络</li><li>按使用者分：公用网，专用网</li><li>按传输介质分：有线网络，无线网络</li><li>按覆盖范围分：广域网WAN，城域网MAN，局域网LAN，个域网PAN(无线个人区域网WPAN)</li><li>按拓扑结构分：总线型，星型，环型，网状型（多用于广域网）</li></ul><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>速率 ，带宽，吞吐量，时延，时延带宽积，往返时间RTT，利用率，丢包率</p><p>大写K在数据量中为2^10^，小写k在速率中单位为10^3^</p><img src="https://s2.loli.net/2022/07/14/WcECASyevKlfdjT.png" alt="K和k" style="zoom:33%;"><p>网络时延：发送时延，传播时延(自由空间3x10^8^m/s,铜线 2.3x10^8^m/s,光纤2.0x10^8^m/s)，处理时延,排队时延。</p><p>利用率：</p><ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均</li></ul><blockquote><p>此处有个公式   D=D<del>0</del>/(1-U)</p></blockquote><p>丢包率：接口丢包率，结点丢包率，链路丢包率，路径丢包率，网络丢包率</p><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><p>OSI体系结构（开发系统互连参考模型）</p><img src="https://s2.loli.net/2022/07/14/5tuk7e9cCj4EBZx.png" alt="计算机网络体系结构" style="zoom: 25%;"><p><span class="github-emoji"><span>🏂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><!--湖科大教书匠 P8 P9总结的好-->   <a href="https://www.bilibili.com/video/BV1c4411d7jb?p=8&amp;vd_source=2f589c6fb6eec38e1c1a980438c16f59">计网总概括</a> 分层思想</p><img src="https://s2.loli.net/2022/07/14/7sQyiMzvXjckVbA.png" alt="计算机网络总概括" style="zoom: 33%;"><blockquote><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><font color="red">浏览器和Web服务器的实际交互过程</font></p></blockquote><p>专用术语：</p><ul><li>实体：对等实体</li><li>协议：每层的协议，逻辑通信，==水平的==<ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>时序：定义通信双方的时序关系</li></ul></li><li>服务：==垂直的==</li></ul><p>服务访问点</p><p>服务原语</p><blockquote><p>协议数据单元PDU：对等层次之间传送的数据包称为~。比特流，帧，ip数据报/分组，报文段，报文</p><p>服务数据单元SDU：同一层内，层与层之间交换的数据包称为~。</p></blockquote><p>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h4><p><font color="red">1.物理层解决如何在连接各种计算机的传输媒体上传输比特流数据，而不是指具体的传输媒体。</font></p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>2.物理层特性：</p><ul><li>机械特性:指明在接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一电平的电压的意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ul><p>3.码元传输速率   &amp;   信息传输速率</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>4.奈氏准则  香农定理</p><ul><li>奈氏准则（奈奎斯特定理</li></ul><p>为了解决码间串扰</p><blockquote><p>在理想低通（没有噪声。带宽有限）的信道中，为了避免码间串扰，极限码元传输速率为2W波特（Baud）。其中W是理想低通信道的带宽。V表示每个码元离散电平数目。</p></blockquote><blockquote><p>理想低通信道下的极限数据传输速率=2Wlog2V  （单位b/s）</p></blockquote><p><font color="green">奈氏准则给出了码元传输速率的限制，并未对信息传输速率给出限制。</font></p><ul><li>香农定理</li></ul><p>香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输速率，当用此速率进行传输，可以做到不产生误差。</p><blockquote><p>信道的极限数据传输速率=wlog2(1+S/N)   b/s</p><p>w为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，单位dB,</p><p>信噪比=10log10(S/N)</p></blockquote><p>5.编码与调制</p><p>6.电路交换，报文交换，分组交换</p><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>导向型传输介质（固体媒介<ul><li>双绞线<ul><li>屏蔽双绞线STP</li><li>非屏蔽双绞线UTP</li></ul></li><li>同轴电缆</li><li>光纤<ul><li>多模光纤</li><li>单模光纤</li></ul></li></ul></li><li>非导向性传输介质（自由空间<ul><li>无线电波</li><li>微波</li><li>红外线，激光</li></ul></li></ul><h4 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h4><ul><li>中继器</li></ul><p>5-4-3规则</p><ul><li>集线器（多口中继器</li></ul><h4 id="sparkles-信道复用技术"><a href="#sparkles-信道复用技术" class="headerlink" title=":sparkles:信道复用技术"></a><span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>信道复用技术</h4><h3 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h3><h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><p>功能：</p><ul><li>为网络层提供服务<ul><li>无确定无连接服务</li><li>有确认无连接服务</li><li>有确认面向连接服务</li></ul></li><li>链路管理</li><li>组帧</li><li>流量控制</li><li>差错控制（帧错/位错）</li></ul><h4 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h4><p>1.<font color="red">给IP数据报添加帧首部和帧尾部</font></p><p>2.首部尾部的重要作用：帧定界</p><p>3.帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><table><thead><tr><th>帧首部</th><th>帧的数据部分</th><th>帧尾部</th></tr></thead><tbody><tr><td></td><td>&lt;=最大传送单元MTU</td><td></td></tr></tbody></table><p>4.组帧的四种方法</p><ul><li>字符计数法：帧首部使用一个计数字段来标明段内字符数。    /易出错</li><li>字符(节)填充法：<code>SOH|     |ESC|EOT|     |ESC|SOH|      |ESC|ESC|    |EOT|</code>     添加转义字符ESC</li><li>零比特填充法:在发送端，扫描整个信息字段，只要连续五个1填充一个0</li><li>违规编码法：曼彻斯特只有高-低和低-高，因此用高-高，低-低来定界帧的起始和终止。</li></ul><p>5.透明传输：发送啥，接收啥</p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>位错<ul><li>检错编码<ul><li>奇偶校验码</li><li>循环冗余码CRC</li></ul></li><li>纠错编码：海明码</li></ul></li><li>帧错（在后面章节</li></ul><h4 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h4><p>流量控制：链路层（点对点，接收方收不下不回复确认），传输层（端到端，接收端给发送端一个窗口公告）</p><p><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>流量控制方式：</p><ul><li><p>停止-等待协议（发送窗口大小&amp;接收窗口大小=1）</p><ul><li>无差错情况</li><li>有差错情况<ul><li>数据帧丢失或检测到帧出错</li><li>ACK丢失</li><li>ACK迟到</li></ul></li></ul></li><li><p>滑动窗口协议</p><ul><li>后退N帧协议GBN:若采用n比特对帧编号，那么发送窗口的尺寸WT应该满足：1&lt;=WT&lt;=2的n次方-1；比如2比特，[1，3]</li><li>选择重传协议SR:发送窗口=接收窗口，WTmax=WRmax=2的(n-1)次方</li></ul></li></ul><p><span class="github-emoji"><span>💨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a8.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><font color="red">信道利用率，信道吞吐量计算</font></p><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><p><font color="gold">目的：采取一定措施，使得两对节点之间的通信不会发生相互干扰的情况</font></p><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>介质访问控制：</p><ul><li><p>静态划分信道</p><ul><li>频分多路复用FDM</li><li>时分多路复用TDM</li><li>波分多路复用WDM</li><li>码分多路复用CDM</li></ul></li><li><p>动态分配信道</p><ul><li><p>轮询访问介质访问控制</p><ul><li>轮询协议</li><li>令牌传递协议</li></ul></li><li><p>随机访问介质访问控制</p><ul><li>ALOHA协议<ul><li>纯ALOHA协议</li><li>时隙ALSHA协议</li></ul></li><li>CSMA协议：载波监听多路访问协议<ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>P-坚持CSMA</li></ul></li><li>CSMA/CA协议：载波监听多点接入/碰撞避免</li><li>CSMA/CD协议：载波监听多点接入/碰撞检测  <font color="bluef">截断二进制指数规避算法</font></li></ul></li></ul></li></ul><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><p>1.局域网分类：</p><ul><li>以太网：802.3</li><li>令牌环网：802.5</li><li>FDDI网：802.8 光纤技术咨询组</li><li>ATM网：</li><li>无线局域网：802.11   wifi是其中一种应用</li></ul><p>2.802将数据链路层划分为：</p><ul><li>逻辑链路层LLC子层</li><li>介质访问控制MAC子层</li></ul><h4 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h4><h4 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h4><p>网桥</p><p>交换机</p><h3 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h3><h3 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h3><h4 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h4><p>TCP：面向连接的传输控制协议TCP；可靠，面向连接，时延大，适用于大文件</p><p>UDP：无连接的用户数据报协议UDP；不可靠，无连接，时延小，适用于小文件</p><p>端口号（只具有本地意义，端口号长16bit，能表示65536个不同端口号</p><ul><li>服务端使用的端口号<ul><li>熟知端口号：0-1023</li><li>登记端口号：1024-49151</li></ul></li><li>客户端使用的端口号：49152-65536</li></ul><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td></tr></tbody></table><table><thead><tr><th>HTTP</th><th>SNMP</th></tr></thead><tbody><tr><td>80</td><td>161</td></tr></tbody></table><p>套接字（socket）=（主机ip地址，端口号）</p><h3 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h3><h4 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h4><p>1.应用层对应用程序的通信提供服务</p><p>2.应用层功能：</p><ul><li>文件传输、访问和管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>3.应用层协议</p><p><font color="red">FTP(TFTP); SMTP,POP3,IMAP; HTTP; DNS</font></p><p>4.网络应用模型</p><ul><li>客户/服务器模型(client/server)</li><li>P2P模型（peer-to-peer)</li></ul><h4 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h4><blockquote><p><font color="greenn">域名解析系统  端口号53</font></p></blockquote><p>1.DNS实现：域名替代IP地址</p><p>2.域名</p><ul><li>顶级域名<ul><li>国家顶级域名  cn,us,uk</li><li>通用顶级域名  com,net,org,gov,int,aero,museum,travel</li><li>基本结构域名/反向域名 arpa</li></ul></li><li>二级域名<ul><li>类别域名  ac,com,edu,gov,mil,net,org</li><li>行政域名  用于我省，自治区，直辖市 bj，js</li><li>自己创造的域名  cskaoyan…</li></ul></li><li>三级域名</li><li>四级域名</li></ul><p>3.DNS服务器划分</p><ul><li>本地域名服务器</li><li>根域名服务器      a.rootservers.net   a-m</li><li>顶级域名服务器</li><li>权限域名服务器</li></ul><p>4.域名解析过程</p><ul><li>递归查询</li><li>迭代查询</li></ul><p>高速缓存</p><h4 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h4><blockquote><p><font color="greenn">文件传送协议FTP    端口号21</font></p><p>简单文件传送协议TFTP</p></blockquote><p>1.提供不同种类主机系统之间的文件传输能力</p><p>2，FTP工作原理</p><p>TCP控制连接端口21  传请求 一直打开</p><p>TCP数据连接端口20 传文件  //主动方式使用TCP20  被动方式由C,S协商决定，TCP端口&gt;1024</p><p>3.FTP传输格式</p><ul><li>文本模式：ASCII模式</li><li>二进制模式：Binary模式</li></ul><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><blockquote><p><font color="bluee">SMTP：简单邮件传送协议</font> <!--通用因特网扩充MIME--> TCP连接 端口号25 C/S</p><p><font color="bluee">POP3：邮局协议POP3</font>   端口号110  TCP连接  C/S</p><p><font color="bluee">IMAP：网际报文存取协议IMAP</font>   端口号143</p></blockquote><p>SMTP仅限传送7位ASCII码</p><p>…</p><p>基于万维网的电子邮件</p><h4 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h4><p>www</p><p>1.统一资源定位符URL→唯一标识     资源</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>eg:<a href="http://www/pku.edu.cn">http://www/pku.edu.cn</a></p><p>万维网使用HTML</p><p>HTTP端口80</p><p>2.HTTP连接方式：</p><ul><li>持久连接Keep-alive<ul><li>非流水线</li><li>流水线</li></ul></li><li>非持久连接 Close</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab</title>
      <link href="/2022/07/03/matlab/"/>
      <url>/2022/07/03/matlab/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://img-baofun.zhhainiao.com/fs/f0f4698d3237425e56ebf4a09f56a538.jpg">https://img-baofun.zhhainiao.com/fs/f0f4698d3237425e56ebf4a09f56a538.jpg</a></p><img src="https://s2.loli.net/2022/08/16/zIGtZfi4mnHeAhd.jpg" alt="4272972675" style="zoom: 50%;">]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K&amp;R the c</title>
      <link href="/2022/07/03/K&amp;R%20the%20c/"/>
      <url>/2022/07/03/K&amp;R%20the%20c/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h3 id="第二章-计算"><a href="#第二章-计算" class="headerlink" title="第二章 计算"></a>第二章 计算</h3><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>单精度浮点数：float   %f     </p><p>双精度浮点数：double  %lf</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><blockquote><p>单目运算符   赋值运算符</p></blockquote><blockquote><p>a=b+5    a,b,5是算子，=，+是运算符</p></blockquote><p>优先级数字越大，越后运算</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合律</th></tr></thead><tbody><tr><td>1</td><td>后缀运算符：[]   ()   ·   -&gt;   ++   –(类型名称){列表}</td><td>从左到右</td></tr><tr><td>2</td><td>一元运算符：++   –   !   ~   +   -   *   &amp;   sizeof_Alignof</td><td>从右到左</td></tr><tr><td>3</td><td>类型转换运算符：(类型名称)</td><td>从右到左</td></tr><tr><td>4</td><td>乘除法运算符：*   /   %</td><td>从左到右</td></tr><tr><td>5</td><td>加减法运算符：+   -</td><td>从左到右</td></tr><tr><td>6</td><td>移位运算符：&lt;&lt;   &gt;&gt;</td><td>从左到右</td></tr><tr><td>7</td><td>关系运算符：&lt;&lt;=   &gt;&gt;=</td><td>从左到右</td></tr><tr><td>8</td><td>相等运算符：==   !=</td><td>从左到右</td></tr><tr><td>9</td><td>位运算符 AND：&amp;</td><td>从左到右</td></tr><tr><td>10</td><td>位运算符 XOR：^</td><td>从左到右</td></tr><tr><td>11</td><td>位运算符 OR：|</td><td>从左到右</td></tr><tr><td>12</td><td>逻辑运算符 AND：&amp;&amp;</td><td>从左到右</td></tr><tr><td>13</td><td>逻辑运算符 OR：||</td><td>从左到右</td></tr><tr><td>14</td><td>条件运算符：?:</td><td>从右到左</td></tr><tr><td>15</td><td>赋值运算符：    =     +=     -=    *=    /=    %=    &amp;=    ^=    |=     &lt;&lt;=    &gt;&gt;=</td><td>从右到左</td></tr><tr><td>16</td><td>逗号运算符：，</td><td>从左到右</td></tr></tbody></table><p>一般不要写嵌入式赋值，不利于阅读，容易产生错误</p><p><code>int c = 1+（b=a）</code></p><h4 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h4><h4 id="复合赋值和递增递减"><a href="#复合赋值和递增递减" class="headerlink" title="复合赋值和递增递减"></a>复合赋值和递增递减</h4><p><code>total +=(sum+200)/2</code></p><p>前缀形式a++ 后缀形式++a</p><p>++</p><p>– </p><blockquote><p><font color="red">a++的值是a加1以前的值，++a的值是加了1以后的值，无论哪个，a自己的值都加了1</font></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    b=a++; <span class="comment">/*此时先进行运算，再给a加1，所以b为5*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a1=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b1;</span><br><span class="line">    b1=++a1; <span class="comment">/*先给a1加1，再运算，所以结果为6*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">输出 <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure><h3 id="第三章-判断与循环"><a href="#第三章-判断与循环" class="headerlink" title="第三章 判断与循环"></a>第三章 判断与循环</h3><h4 id="做判断"><a href="#做判断" class="headerlink" title="做判断"></a>做判断</h4><p>if语句</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if （条件成立）{</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="判断的条件"><a href="#判断的条件" class="headerlink" title="判断的条件"></a>判断的条件</h4><blockquote><p>所有的关系运算符的优先级比算术运算的优先级低，比赋值运算的高</p></blockquote><blockquote><p>判断是否相等的==和！=优先级比其他低，而连续的关系运算符是从左到右进行的</p><p>5&gt;3==6</p><p>6&gt;5&gt;4</p><p>a==b ==6     输出永远为0，因为a == b的结果只能为1或者0</p><p>a==b&gt;0</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">6</span>&gt;<span class="number">5</span>&gt;<span class="number">4</span>);</span><br><span class="line">输出 <span class="number">0</span>  ，先判断<span class="number">6</span>&gt;<span class="number">5</span>结果为<span class="number">1</span>，再判断<span class="number">1</span>&gt;<span class="number">4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">5</span>&gt;<span class="number">3</span>==<span class="number">6</span>&gt;<span class="number">4</span>);</span><br><span class="line">输出 <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><p>否则的话</p><blockquote><p>if(条件成立){…}</p><p>else{…}</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="type">int</span> num=b;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">    {</span><br><span class="line">        num=a;    <span class="comment">//很精炼的只用了一次if判断</span></span><br><span class="line">    }</span><br><span class="line"><span class="comment">//比先对num初始化在进行if，else的代码妙太多了</span></span><br></pre></td></tr></tbody></table></figure><p><font color="blue">==if语句这一行结束并没有分号；==</font></p><h4 id="嵌套的if-else"><a href="#嵌套的if-else" class="headerlink" title="嵌套的if-else"></a>嵌套的if-else</h4><blockquote><p><font color="blue">在if中嵌套if语句或者if-else</font></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*三个数中找最大值*/</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b){</span><br><span class="line">       <span class="keyword">if</span>(a&gt;c)</span><br><span class="line">           max=a;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           max=c;}</span><br><span class="line">   <span class="keyword">else</span>{</span><br><span class="line">       <span class="keyword">if</span>(b&gt;c)</span><br><span class="line">           max=b;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           max=c;}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="gold">else总是和最近的那个if匹配</font></p><p><font color="red">缩进格式不能暗示else的匹配</font></p></blockquote><h4 id="级联的if-else-if"><a href="#级联的if-else-if" class="headerlink" title="级联的if-else if"></a>级联的if-else if</h4><p>分段函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)  <span class="comment">//犯的错误：把=当作相等了</span></span><br><span class="line">    f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    f=<span class="number">2</span>*x;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>if（expl){…}</p><p>else{</p><p>if(exp2){…}</p><p>else{…}</p><p>}</p><p><font color="greenf">在第一个else里面嵌套一个if-else,之前以为else if是一个整体</font>,else if放一起其实是一种编排方式</p></blockquote><h4 id="if-else常见错误"><a href="#if-else常见错误" class="headerlink" title="if-else常见错误"></a>if-else常见错误</h4><p>1.忘了大括号</p><p>2.if后面加了分号</p><blockquote><p>if(age&gt;60);</p><p>相当于：</p><p><font color="greenr">if（age&gt;60)</font></p><p><font color="greenr">;</font></p><p>有一个空语句</p></blockquote><p>3.错误使用==和=，（上面刚犯</p><p>尊重==warning==</p><p>4.代码风格</p><p>大括号，缩进</p><h4 id="多路分支（switch-zap"><a href="#多路分支（switch-zap" class="headerlink" title="多路分支（switch :zap:"></a>多路分支（switch <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>​switch-case：程序跳转到相匹配的case分支处。执行完某个分支如果没有break，则会顺序</p><p>执行到下一个case，直到碰见break</p><blockquote><p>必须是int类型</p><p>常量可以是常数，也可以是常数计算的表达式</p></blockquote><p>switch比多次else if更加快捷，是跳转执行的。以后用数组更加方便<br>$$<br>f(x)=\begin{cases}<br>-1 &amp; x&lt;0 \<br>0 &amp; x=0 \<br>2x &amp; x&gt;0<br>\end{cases}<br>$$</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//用switch表示分段函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x,f;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">switch</span> (x&gt;<span class="number">0</span>){</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: f = <span class="number">2</span>*x; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">switch</span>(x==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: f = <span class="number">0</span> ; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: f = <span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*百分制成绩转换为五分制</span></span><br><span class="line"><span class="comment">·大于等于90为A；</span></span><br><span class="line"><span class="comment">·小于90且大于等于80为B；</span></span><br><span class="line"><span class="comment">·小于80且大于等于70为C；</span></span><br><span class="line"><span class="comment">·小于70且大于等于60为D；</span></span><br><span class="line"><span class="comment">·小于60为E;</span></span><br><span class="line"><span class="comment">输入格式：</span></span><br><span class="line"><span class="comment">输入在一行中给出1个整数的百分制成绩。</span></span><br><span class="line"><span class="comment">输出格式：</span></span><br><span class="line"><span class="comment">在一行中输出对应的五分制成绩</span></span><br><span class="line"><span class="comment">输入样例：</span></span><br><span class="line"><span class="comment">90</span></span><br><span class="line"><span class="comment">输出样例：</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;score);</span><br><span class="line">    score/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">switch</span>(score){   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"A"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"C"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"E"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法是用十位数判断case 。。。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="第四章-循环"><a href="#第四章-循环" class="headerlink" title="第四章 循环"></a>第四章 循环</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个数，判断位数</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">n++;</span><br><span class="line">x/=<span class="number">10</span>;     <span class="comment">//去掉个位</span></span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>){</span><br><span class="line">    n++;</span><br><span class="line">    x/=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br></pre></td></tr></tbody></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><img src="https://pic2.zhimg.com/v2-15b1f4ffbbdeb32c25025e5e61231d91_r.jpg" style="zoom:67%;"><blockquote><p>当条件满足时，不断地重复循环体内的语句。while循环有可能一次循环都没有</p></blockquote><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><blockquote><p>do</p><p>{&lt;循环体语句&gt;</p><p>}while(&lt;循环条件&gt;);</p></blockquote><img src="https://pic2.zhimg.com/80/v2-8e4a91ba1473adc7b05ad95e76c110f9_720w.jpg" style="zoom: 67%;"><p><font color="red">do while先进行循环体，再判断条件</font></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">        n++;</span><br><span class="line">    }<span class="keyword">while</span>(x&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line"><span class="comment">//while 和do while在此程序都有缺陷，因为0的时候位数为1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a>循环计算</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*计算log2的x次方*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x,t;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    t = x;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>){</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">        ret++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"log2 of %d is %d"</span>,t,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//猜数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> number = rand()%<span class="number">100</span>+<span class="number">1</span>; <span class="comment">//每次召唤rand（）就得到一个随机的整数</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我已经想好一个1到100之间的数:\n "</span>);</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请猜这个1到100之间的数: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;number){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"你猜的数大了"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;number){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"你猜的数小了"</span>);</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">while</span>(a!=number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"你用了%d次猜中"</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>、</p><h3 id="第五章-数组"><a href="#第五章-数组" class="headerlink" title="第五章 数组"></a>第五章 数组</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*随机生成十个整数，找出最大值最小值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//怎么随机输入十个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="type">int</span> max,min;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//种子，为了保证每次调用随机数不同 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"此次随机生成的a[10]={"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//程序每次运行，随机数结果都是一样的</span></span><br><span class="line">        a[i]=rand() % <span class="number">999</span>+<span class="number">1</span>;  <span class="comment">//伪随机数</span></span><br><span class="line">       <span class="comment">// scanf("%d",&amp;a[i]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"}\n"</span>);</span><br><span class="line">    min=max=a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;max)</span><br><span class="line">            max=a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;min)</span><br><span class="line">            min=a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max=%d\n"</span>,max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min=%d\n"</span>,min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小，从小到大排序，逆序</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>此次随机生成的a[10]={669 168 866 674 880 551 161 794 119 830 }<br>max=880<br>min=119</p></blockquote><h3 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a>第六章 指针</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp=*px;</span><br><span class="line">    *px=*py;</span><br><span class="line">    *py=tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*px = %d, *py = %d\n"</span>,*px,*py);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    Swap(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第七章-指针"><a href="#第七章-指针" class="headerlink" title="第七章   指针"></a>第七章   指针</h3><h5 id="指针与自增、自减"><a href="#指针与自增、自减" class="headerlink" title="指针与自增、自减"></a>指针与自增、自减</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>]={<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    p=a;  <span class="comment">//让指针变量p，指向数组开头</span></span><br><span class="line">    j=*p++;<span class="comment">//后++的时候，第一步把++去掉，j=*p,第二步p++，</span></span><br><span class="line">    <span class="comment">//第二部看另外一个优先级是否高于++  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d,j=%d,*p=%d\n"</span>,a[<span class="number">0</span>],j,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>,j=<span class="number">2</span>,*p=<span class="number">7</span></span><br><span class="line">请按任意键继续. . .</span><br><span class="line">    </span><br><span class="line">如果：  </span><br><span class="line">j=(*p)++;</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">3</span>,j=<span class="number">2</span>,*p=<span class="number">3</span></span><br><span class="line">请按任意键继续. . .</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p是指向地址空间    ，p++意思就是指向下一个空间了</span></span><br><span class="line">    <span class="comment">//*p是指向空间里面的值，（*p）++是值+1；  *p等价于a[0],是值</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>]={<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    p=a;  <span class="comment">//让指针变量p，指向数组开头</span></span><br><span class="line">    j=*p++;<span class="comment">//后++的时候，第一步把++去掉，j=*p,第二步p++，</span></span><br><span class="line">    <span class="comment">//第二部看另外一个优先级是否高于++  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d,j=%d,*p=%d\n"</span>,a[<span class="number">0</span>],j,*p);<span class="comment">//2 2 7</span></span><br><span class="line">    j=p[<span class="number">0</span>]++;<span class="comment">//j=p[0];p[0]++    []优先级高于++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d,j=%d,*p=%d\n"</span>,a[<span class="number">0</span>],j,*p);<span class="comment">//2 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h5><p>函数调用是值传递,数组传递是弱化为指针</p><p>*d就是d[]</p><p><font color="erebgeryea">指针的传递和偏移</font></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//数组名作为实参传递给予函数时，是弱化为指针的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> *d)</span>  <span class="comment">//d是传递的地址  *d是h</span></span><br><span class="line">{</span><br><span class="line">    *d = <span class="string">'H'</span>;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="string">'E'</span>;</span><br><span class="line">    *(d+<span class="number">2</span>)=<span class="string">'L'</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,d[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> c[<span class="number">10</span>]=<span class="string">"hello"</span>;</span><br><span class="line">    change(c);</span><br><span class="line">    <span class="comment">//puts(c);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">HELlo</span><br><span class="line">请按任意键继续.</span><br></pre></td></tr></tbody></table></figure><h5 id="指针与动态内存申请-malloc"><a href="#指针与动态内存申请-malloc" class="headerlink" title="指针与动态内存申请 malloc"></a>指针与动态内存申请 malloc</h5><blockquote><p>5</p><p>申请5*sizeof(int)=20个字节</p></blockquote><blockquote><p>数组一开始定义就确定下来了，数组是放在栈空间的 ，其实c语言的数组长度固定是因为其定义的整型、浮点型、字符型变量、数组变量都在栈空间。而栈空间的大小在编译时是确定的。</p><p>如果使用的空间大小不确定，那么就要使用堆空间。</p><p>程序是放在磁盘上的有序的指令集合。</p><p>程序启动起来才叫进程</p></blockquote><p>进程地址空间：</p><ul><li>栈：自动分配，效率高</li><li>堆：像图书馆，要借</li></ul><p>void 什么都不需要返回；void * 返回无类型指针</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//malloc可以帮我们实现动态数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//申请多大的空间</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;i);</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//malloc申请空间的单位是字节</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"malloc success"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放空间，p的值必须和最初malloc返回的值一致</span></span><br><span class="line">    p= <span class="literal">NULL</span>;<span class="comment">//如果不把p值置位null，就是野指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="built_in">malloc</span> success</span><br><span class="line">请按任意键继续. . .</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>看到1：11</p><h5 id="栈空间与堆空间的差异"><a href="#栈空间与堆空间的差异" class="headerlink" title="栈空间与堆空间的差异"></a>栈空间与堆空间的差异</h5><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">print_stack</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> c[<span class="number">17</span>]=<span class="string">"I am print_stack"</span>;</span><br><span class="line">    <span class="built_in">puts</span>(c);  <span class="comment">//可以正常打印</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">print_malloc</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span>* p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">30</span>);   <span class="comment">//堆空间一直可以使用</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"I am print_malloc"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = print_stack();<span class="comment">//栈空间会随着函数的执行结而释放 </span></span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    p=print_malloc();<span class="comment">//堆空间不会随着子函数的结束而释放，除非主动free</span></span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">I am print_stack</span><br><span class="line">I am print_malloc</span><br><span class="line">I am print_malloc</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></tbody></table></figure><h3 id="第八章-结构体"><a href="#第八章-结构体" class="headerlink" title="第八章  结构体"></a>第八章  结构体</h3><p><strong>枚举</strong></p><blockquote><p>enum 枚举类型名字{名字0，名字1，…..名字n}；</p><p>enum colors{red，yellow，green}；</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>{</span>red,yellow,green};</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">t</span> =</span>red;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    f(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>结构</strong></p><blockquote><p>一个结构就是复合的数据类型</p><p>struct point {</p><p>int x;</p><p>int y;</p><p>}P1,P2;</p></blockquote><blockquote><p>访问结构里面的成员，用  .   ，today.day</p><p>和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符</p><p>struct date *pDate =&amp;today;</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span>{</span></span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">    };</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span></span><br><span class="line">    today.month=<span class="number">07</span>;</span><br><span class="line">    today.day=<span class="number">31</span>;</span><br><span class="line">    today.year=<span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"today's date is %i-%i-%i.\n"</span>,today.year,today.month,today.day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>{</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span>{<span class="number">07</span>,<span class="number">31</span>,<span class="number">2014</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span>&amp;today;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"today's date is %i-%i-%i.\n"</span>,today.year,today.month,today.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address of today is %p\n"</span>,pDate);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*today's date is 2014-7-31.</span></span><br><span class="line"><span class="comment">address of today is 000000000061FE0C</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请按任意键继续. . .*/</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结构与函数</strong></p><blockquote><p>int number0fDays(struct date d)</p><p>指向结构的指针：   -&gt;</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>{</span></span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">}myday;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday;</span><br><span class="line">(*p).month =<span class="number">12</span>;</span><br><span class="line">p-&gt;month =<span class="number">12</span>;</span><br></pre></td></tr></tbody></table></figure><p>联合</p><h3 id="第九章-函数"><a href="#第九章-函数" class="headerlink" title="第九章 函数"></a>第九章 函数</h3><h5 id="函数的声明、定义与调用"><a href="#函数的声明、定义与调用" class="headerlink" title="函数的声明、定义与调用"></a>函数的声明、定义与调用</h5><h5 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h5>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0</title>
      <link href="/2022/07/03/0/"/>
      <url>/2022/07/03/0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">美好的大学四年都献给了疫情，当然这不是借口</font></p></blockquote><p>2022/7//10</p><p><font color="green">如果想要产生羁绊，就要承担流泪的风险</font></p><blockquote><p>我们常常认为努力就会有回报</p><p>但事实并非如此</p><p>你取得成就很可能是环境的馈赠</p><p>你们之所以能通过努力取得成功</p><p>实际上是整个社会在不断鼓励你</p><p>把最优质的资源向你们倾斜</p><p>并在过程中给予你奖励和反馈</p><p>才有了你最后的辉煌成就</p><p>因此请不要标榜自己的“努力”<!--高考或许我没有怎么努力--></p><p>一心追逐个人的功成名就</p><p>不要因自己在环境助力下获得成功</p><p>就指责他人的不幸是因为“不够努力”</p><p>请尽你所能向弱者伸出援手</p><p>承认自身的缺点与局限</p><p>而不是聚焦放大自己的努力和天赋</p><p>让自我与时代相互成就吧</p><!--东京大学教授入学致辞--></blockquote><p>2022/7/21</p><blockquote><p><font color="blueb">希望被蒸发了以后<br>眼泪是否还舍得流<br>灵魂是否还能祈求<br>徘徊在幽谷的念头</font></p></blockquote><blockquote><p><font color="glodennn">凭什么要失望</font><br><font color="glodennn">藏眼泪到心脏</font></p></blockquote><p>加油，，闭关，，基础。</p><p>2022/7/24</p><blockquote><p><font color="red"><span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>进复试吧求求了，加油坚持，至少去看看,75 75 110 110，头大，还有好多知识</font></p></blockquote><p>2022/7/26</p><p>此刻的想法：</p><p>人生不能固定到一个模板一个套路（结婚生子教育终老死亡），没必要为了不存在的人或者物所奋斗（伴侣，家庭），历史上留名的少年英杰（为什么会留名呢，）昙花一现的霍去病？</p><p>追寻自己的人生，喜欢孩子也可以去收养？，别为了这些去迎合别人别为了这些压力自己，压垮自己。</p><p>做自己真正想要做的事情（独处，书法也好健身看番也罢，都是满足自己，人终有一死。。活在当下，</p><p>lawliet</p><p>7/29</p><blockquote><p><font color="red">行百里者半九十<span class="github-emoji"><span>😐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f610.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></font></p><p><font color="gold">行胜于言</font></p></blockquote><p>2022/8/4</p><p>七夕快乐0</p><p>8/13  </p><p>疲倦，看似学了很多，感觉和没学一样</p><blockquote><p><font color="#DB70DB">融会贯通&nbsp;&nbsp;</font><font color="#38B0DE ">行胜于言&nbsp; &nbsp;</font><font color="\#70DBDB ">总结&nbsp;</font></p></blockquote><p><font color="#7093DB ">8.30前完成高数线代基础，机组也要完成，操作系统看情况，数据结构可以和王道c督学一起复习，408搞完在进入二轮.九月应该进行强化了，九月强化要全部完成;英语单词每天背诵，政治每天两个视频这样，英语先搞词汇量</font></p><p><font color="#70DBDB">尽快搞定c语言，多刷基础题，二级过不了就可以去楼顶了，9月开始要能刷力扣</font></p><p><font color="#70DB93">英语希望可以过六级，起码500分，然后数据结构课必须90+，没得商量。</font></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jaehong Kim</title>
      <link href="/2022/07/03/Jaehong%20Kim/"/>
      <url>/2022/07/03/Jaehong%20Kim/</url>
      
        <content type="html"><![CDATA[<blockquote><p>if you see me after class<br>please say hi to me<br>don’t forget<br>your time flies fast<br>so if you don’t enjoy<br>you’re regret a lot<br>seriously,your time is very precious<br>this is your prime time<br>look at the movies and then tv3<br>who is leading actor,who is leading actress,at your age,ok?<br>so just,i mean,use your time<br>enjoy your life<br>looks like your Chinese,you’re very good<br>you just study hard,don’t enjoy much<br>looks like you give up your current time for future<br>but your current time is more valuable than the future<br>then one hour ,you’re fifty sixty<br>your time now is more important<br>i think I’ve said before<br>when i took the linear algebra<br>i got an F,so i had to retake<br>you’re a lot better than me<br>it doesn’t matter,just enjoy your life<br>let’s take a quiz,quiz is simple<br>(小测内容：选择0-10的整数作为小测成绩)<br>if you want,you can write down zero,it’s up to you</p></blockquote><p>等考上了就好好享受学习、生活</p><p><font color="red">一语惊醒梦中人,等我考上了就享受学习，做好当下事🎬 </font><br><font color="purple">所有的不幸都是当事人的能力不足，要诅咒，就该诅咒自己的弱小.</font></p><p><font size="6"><font style="font-family:'隶书';">中国传统色</font></font></p><p><font color="#A4CAB6">玉簪</font> <font color="#69A794">梧枝</font> <font color="5DBE8A">蔻梢</font> <font color="41B349">玉髓</font> <font color="2C9678">青矾</font> <font color="#428675">亚丁</font> <font color="#248067">海王</font></p><p><font color="#BACCD9">云水</font> <font color="#8FB2C9">晴山</font> <font color="#8ABCD1">秋波</font> <font color="#10AEC2">甸子</font> <font color="#158BB8">鸢尾</font> <font color="#4E7CA1">蝶翅</font> <font color="#2775B6">景泰</font></p><p><font color="#FED71A">佛手</font> <font color="#F9D770">淡茧</font> <font color="#FCCB16">素馨</font> <font color="#FCC307">金盏</font> <font color="#FEBA07">琥珀</font> <font color="#F9A633">榴萼</font> <font color="#DAA45A">玳瑁</font></p><p><font color="#F03752">海棠</font> <font color="#ee2746">淡曙</font> <font color="#c21f30">枫叶</font> <font color="#ee3f4d">茶花</font> <font color="#bf3553">锦葵</font> <font color="#a7535a">满江</font> <font color="#82111f">殷红</font> </p><p><font color="#E9CCD3">芝兰</font> <font color="#C08EAF">萝兰</font> <font color="#C06F98">樱草</font> <font color="#806D9E">槿紫</font> <font color="#815C94">蕈紫</font> <font color="#813C85">桔梗</font> <font color="#4D1018">酱紫</font> </p><p><font color="#3E3B31">茶青</font> <font color="#31322C">京元</font> <font color="#39363F">鹰背</font> <font color="#353538">烟墨</font> <font color="#2D2D30">朱墨</font> <font color="#2E282E">石青</font> <font color="#000013">青骊</font> </p><details><summary>于是</summary><blockquote><p>作词：G.E.M. 邓紫棋</p><p>作曲：G.E.M. 邓紫棋</p><p>演唱：G.E.M. 邓紫棋</p><p>于是茶就这样冷了</p><p>于是天就这样亮了</p><p>于是你就这样离开了</p><p>于是我终于醒了</p><p>于是你我从此远了</p><p>于是路从此分岔了</p><p>你的脸从此就陌生了</p><p>虽然我有一点不舍</p><p>可是时间不可能停下　不能停下　不会停下</p><p>世界一直在变幻着　你也变了　我也变了</p><p>过去都已经过去了　既然回不去了　我还在烦恼什么</p><p>于是告诉自己不要哭　我不要哭　我不能哭</p><p>往前方的路走一步　再走一步　就会幸福</p><p>成长要学会独处　虽然有一点孤独</p><p>(Baby you’ve gone far away)</p><p>Therefore I think I should follow, boy</p><p>(When you’ve gone far away)</p><p>Therefore maybe I’m about to go, yeah, because</p><p>(Baby you’ve gone far away)</p><p>I don’t know boy, I don’t really know why, why</p><p>(that you’ve gone far away)</p><p>Therefore, therefore I’m now so alone</p><p>于是花一个人种了</p><p>于是梦一个人做了</p><p>于是痛一个人扛下了</p><p>快乐一个人笑着</p><p>可是时间不可能停下　不能停下　不会停下</p><p>世界一直在变幻着　你也变了　我也变了</p><p>过去都已经过去了　既然回不去了　我还在烦恼什么</p><p>于是告诉自己不要哭　我不要哭　我不能哭</p><p>往前方的路走一步　再走一步　就会幸福</p><p>成长要学会独处　虽然有一点孤独</p><p>Baby you’ve gone, you’ve gone far away</p><p>Baby you’ve gone far away</p></blockquote></details>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孔</title>
      <link href="/2022/07/03/%E5%AD%94/"/>
      <url>/2022/07/03/%E5%AD%94/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="61a73c891ee03c3dda630ea0540036cd8d75eb9cee684e904d76ed0274d518b2">abead2464e4d863de735c795c12ba82c9a48638d297eaf35d300254e6b24200adaf9aba7063de586fd81c6ecd6d837e5da61ad2472207a7f29febc89de23b9a30ebe639dfc1d79573f97235618771d306c467aab33a72520e3ddad548e75cf5578a3a68a8d684a0c799beb2ab41880b24cbcb3644847e11f4b2f16cf492f7f5b892c2a0ffe4b900455b4f8674dc56287213224d406ffcd50ffb16124280c57b78cde5adfe272ddccd97f67420940ad13ec9e081380eefe5a91deed7f95c39b93220c68cf2ac86c4947fc54351d67847115afbfbd1b4467b8a39e062930041b9f910464b0c20f83ba4de5cb7a85250324acef45d43f2014b8608cb122f78286bcb4f573522168fbd9e0fd67214ca11523bd29b5a8d3e1def562b30b89e76bdd434e433e0132c271156912bf3d76b606a1190ff7335a031ad23c25ffae8edc5d7ec44e488d173bf786c1213c8aef90fb11fbc45f5ea4b5be67ebb25497b109db7031d714709a35b832e268a3402d7f446299147909c839af9acd2a79dd5a74387a5f972c08f30280098a2ca20a70abd86172c6fbddfccdce4c0133e19d31cf9c8a02b9589ee10aa49cd3efd0b8916c96c0bad14b6697815d43cda67099dc3c1af4087ef5dfb93755dbd64861563f198248be43429005198ed0fe65968816224fc95600219954c17163aec1f48b202c5c38c088602cd24c66f678329c999f39f58e98e2d8a3751789425ad0c7bd591b7a8522757bd4e33cdcf4d0ad894509669620254e4a5d32bf39387a578b201e31591dc4c50e3e0c013d9b87928343ae4f67573c555247e1cd00950420821e740c93d1e1cdbef5007480342880dc5bec6ad400b9bc43afeeb56b16198bf1ca5f57a700c5bdc6be5d5677b37bd759cd3ee2469ca1257a60583baf7a8e045781f1345f2f0fa10cf2c4f2abcddb21f635728cff8aa358fac02c09f6fd0854d1013268ae6e5cde3f3519380473079ba828beb11220b3fd8a5f794ad2ee70cefb498eeec8c69415cf470d6710936b8b569f84940421d654c61e5bb2ee7270b9a26c7e6a552fbd909486531c5f5991b5dad3341bc9393ca0bc8200e15b4d01b6a81a41ff396bacf5c7240e4f1e2dfac7547861db0d3718c798a6f9c84b0153b61490598d3855fc53d88622e97f729c883da9539acdc8dea6f90a9e8535cad4790d286e8ca52e237b6c5fae86bc6851a1907cd0a18d0d6f75b0a7353ba35a5306cef676abd736e79c998d8978dc6cc58c237b3e694a36b34c5c260185180e5ee94ccfde1429412afa17278962e673fdd6e895b1da9475ee7306262f60bf43d8bb56cd3071a21a5a2083ef39c86d0c7c13f382c73ebe58b7a886b7b1c941d4ad8ebdb455f7ce50c1953d9a12232b89b7cd7083c87336e1107112b789f82643918ccb6875ed3f2614ca0f50a18e5417c43ae41acde04eec89328dc84af22a136a8a0cdc2032947b83472ec6a35007e949cf7e80e5fb0256e2dc4b29f786155261524e7c43a703df7a60e0010cd1bd77995b338baeb2fb95e2f7a6c5187a12023226d1b94e5f0a8d70f5e112e0ea2b4fbdee0b1e52b937129e00d093d54dec6052218af9c6bbd41682352918eff49af2b87211f63e22dd00fb5c2828d288af62c209180d31561013c34dbbacfeae3521464fa3ff1152c6e7a98493d16021be04aa9320f9740b70cab2d26dbc047f62540c0199f6873b465e5fdf0701a0b29fcadbd2a7ecc183c65829769b7fb02703e42d90cbf9cf81c2364e1dcbd6dfb5c34bad1fdc988d199a6f78517b383039597570bfbb1a0361061319177e9d9ba0a98e4ce8c2e54e62719b8d0affa193f594e15d40f5fc3fe2ccfbd732727b4af4696928cd72ddc13d1e9089f3fe67ea6ca66eb82b7187bdcf69e4d5b9f8ad224fa17dc332c1964758b40f82b56129550530bf3c634383190f1de486d916f6739bd7eb82d312365dc5adc98773077565d0e78fda91741e0366271a4bc502fefd8ea5c255db0fa9b0ff3118a32a04bc53f14969e9995365f3d0b9d4cb58f384b89abac589ac19acf4a93a6cc4e5af6864a47d8e89db1fcd8bfc305bb1f7f4efa05a938d2d2f3c4be9cb2578ab9890450231b90156f2d87cd7ff7e5c31108dc547ff3de03c33ee3dd8401711bfb51d2f05a1001856f4d49f7a0fa8632b79ac94edd597ed38b25a8b7b4edefdde331dc38146732ac0dccb16a8667248c749b3d746db6c67f85dfe03ddf23773a4b031a4d67a4bffa7cb6f8f54edccaffea432e8c4db30a3d22f64f32ab122ced66ed6cfce6d843dd090cae30c53cdfa1e37755361cf362999ab46afa6c160697e36a91dadc8ca3244bcbf1825c1a5b91aedd689882233cc0d793db0d36ba13a7c20faa2a4d8707c04e259b57c4a920575d5e1c8ee0b1ac62e744be48618dfb280c66deed8c47cee9aaa0636c886c3b5554e4147f4c85c8812937a1461fa8f0fa5f011f5c511c097b98fe8542cf32ff5d5d63260a8cdbee1bc6b8ac0a9c2201a0551a73e1389a78522693bc9426b7ca7898762093542d6de38ddd6b8b76326a4b4dea19f9b318f759246ca969746f1ee2f01ad629bdbf923b12235deb2ee0e9353533f1687b82f0cadb6d3df00c8949671e173111fb010e7b3a23673be3b6288de260953b6e65afd136bef4cdeeecf5cd34f914d765cde83efe59de8e98afd55b293156b884c83ff0d5bb47a58e81a01a66763a443afad4477df88e77bde5c8b314fa881c69fa695728b62f5ea5ed382cb475d34028b19066aae15d181763b17f6ffa8cca50a28a681711dff0bef43cb84a2a894726760a4c85823a9902c18a476040734b3c5e16365a13693d2aff8a14933fb5cdd20c6b5a6def15fc9b9a47bf1db94945e199be8f28eb2e19d0134c8cce7384b2235553d21558de4a4fadb83e2d10ea7eeb201ad85bcc8d9491504ea869e0f667108137272caab8306396ff661f700665f3ebf5541b73dc7d1670e53f5ea921ae4528a40df3c3556c342e532ce075346c62519365ab87c9729e901a33c1fa77b8acadd38199be81717eeb423859e131e3580bb285c8ff3bf32809e678ff175803c9ac4e23305dcf935e9455abdcad1b418687982b6049a658df25657611a7d6801220299f0fa0598f49302ee385ffaa7afd78347e6ac359aa92026af56c2bc355c653202751e14d48f095d7f12c4c002b8159d785837c1853cc34c47c46af64731ec1fdeb8576a894f637bd116b4b3f11912595f3329f93ee5d72a2751801915e215aaf41470015e71e48ee295a9673902acb54ae050922026d616e1bd31a4ac2681279363baf4f80c4232493e6ad4d658fa5963ca877aad639aab5213cc6e119a648c9c37916e63e7a2dccf5cb20799092e03bdd0ba278a1a059b05d3994ba7af9c693e7faca8911f9d7f3a8e0e7c2641a22ad9628737c110892836610fa57c9dd5314337747ea2b785268018f76d533524f71cb34e2e2ca4e436e470782a8264482fcede3a7dd0df45bdfeaaab1d5cd96e8799fbd225823338eb6dc0b66b5935a852113474be91096ca6dfc05987509af307990673fedddd833e014ea9bd68eefe564da7ed4ef4aa189b98ca78bebfc2924a12470f2c248927e5b2ce8b429b7635adcff7213724ce9c1cad564b4982e5652573c21dce80b7c71518f9f6110b1217163f50778f98499dcefd01a2071283c0f4d2c8e12307e8e70c3a42517f7cc16f92219db25281306a9a42</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七夜雪</title>
      <link href="/2022/07/03/%E4%B8%83%E5%A4%9C%E9%9B%AA/"/>
      <url>/2022/07/03/%E4%B8%83%E5%A4%9C%E9%9B%AA/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="七夜雪"><a href="#七夜雪" class="headerlink" title="七夜雪"></a>七夜雪</h4><blockquote><p>跋涉千里来向你道别<br>在最初和最后的雪夜<br>冰冷寂静的荒原上<br>并肩走过的我们<br>所有的话语 都冻结在唇边<br>一起抬头仰望 你可曾看见<br>七夜的雪花盛放了又枯萎<br>宛如短暂的相聚和永久的离别<br>请原谅于此刻转身离去的我<br>为那荒芜的岁月<br>为我的最终无法坚持<br>为生命中最深的爱恋<br>却终究抵不过时间</p></blockquote><p><span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>🐼</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f43c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h4 id="hexo文章加密"><a href="#hexo文章加密" class="headerlink" title="hexo文章加密"></a>hexo文章加密</h4><blockquote><p>npm install –save hexo-blog-encrypt</p></blockquote><h4 id="改变字体颜色"><a href="#改变字体颜色" class="headerlink" title="改变字体颜色"></a>改变字体颜色</h4><blockquote><p><font color="#FF0000">我是红色字体&lt; font&gt;  后面加个/</font></p><font color="#FF0000"></font></blockquote><font color="#FF0000"><h4 id="页脚渐变"><a href="#页脚渐变" class="headerlink" title="页脚渐变"></a>页脚渐变</h4><p><a href="https://www.cnblogs.com/antmoe/p/12846393.html">参考文章</a></p><p>在blog\themes\butterfly\source\css下建立css文件，然后引用到config.yml文件，引用定位：inject-head</p><blockquote><link rel="stylesheet" href="/css/页脚渐变.css"></blockquote><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">/* 页脚footer */</span><br><span class="line">/* 渐变色滚动动画 */</span><br><span class="line">@-webkit-keyframes Gradient {</span><br><span class="line">    0% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    50% {</span><br><span class="line">        background-position: 100% 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    100% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@-moz-keyframes Gradient {</span><br><span class="line">    0% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    50% {</span><br><span class="line">        background-position: 100% 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    100% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@keyframes Gradient {</span><br><span class="line">    0% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    50% {</span><br><span class="line">        background-position: 100% 50%;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    100% {</span><br><span class="line">        background-position: 0 50%;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">#footer {</span><br><span class="line">    background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab);</span><br><span class="line">    background-size: 400% 400%;</span><br><span class="line">    -webkit-animation: Gradient 10s ease infinite;</span><br><span class="line">    -moz-animation: Gradient 10s ease infinite;</span><br><span class="line">    animation: Gradient 10s ease infinite;</span><br><span class="line">    -o-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    border-top-left-radius: 10px;</span><br><span class="line">    border-top-right-radius: 10px;</span><br><span class="line">}</span><br><span class="line">#footer:before {</span><br><span class="line">    background-color: rgba(0, 0, 0, 0);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h4><p>similar to above</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">/* 滚动条 */</span><br><span class="line">::-webkit-scrollbar {</span><br><span class="line">  width: 8px;</span><br><span class="line">  height: 8px;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track {</span><br><span class="line">  background-color: rgba(73, 177, 245, 0.2);</span><br><span class="line">  border-radius: 2em;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb {</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">  background-image: -webkit-linear-gradient(</span><br><span class="line">    45deg,</span><br><span class="line">    rgba(255, 255, 255, 0.4) 25%,</span><br><span class="line">    transparent 25%,</span><br><span class="line">    transparent 50%,</span><br><span class="line">    rgba(255, 255, 255, 0.4) 50%,</span><br><span class="line">    rgba(255, 255, 255, 0.4) 75%,</span><br><span class="line">    transparent 75%,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  border-radius: 2em;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner {</span><br><span class="line">  background-color: transparent;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">::-moz-selection {</span><br><span class="line">  color: #fff;</span><br><span class="line">  background-color: #49b1f5;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>typora光标切换：小键盘🔒状态按0<img src="https://s2.loli.net/2022/08/16/NRAY6GESy4Us5oF.png" alt="wallhaven-4xg6ro" style="zoom: 25%;"></p><p><img src="https://s2.loli.net/2022/08/16/cp1VbI6CvhnqxQJ.png" alt="ZQ${${4T@0%JEABHXE294}ggg4"><img src="https://s2.loli.net/2022/08/16/e6YfboI3MnyDgFS.png" alt="wallhaven-gjg567 (1)"></p></font>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
